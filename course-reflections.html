<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Concepts in Algorithms</title>
    <style>
        body {
            background-color: #282a36;
            color: #f8f8f2;
            font-family: 'Roboto', sans-serif;
            margin: 0;
            padding: 0;
        }

        h1 {
            color: #f8f8f2;
            font-size: 40px;
            font-weight: bold;
            text-decoration: underline;
            text-align: center;
            margin-top: 30px;
        }

        h3 {
            color: #f8f8f2;
            font-size: 30px;
            margin: 10px 0;
            margin-bottom: 0px;
        }

        p {
            font-size: 20px;
            margin: 0 0 20px 0;
        }

        hr {
            border: 1px solid white;
            width: 100%;
        }

        .content {
            margin: 3cm;
        }

        ul {
            margin: 10px 0;
            padding-left: 20px;
        }

        li {
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <!-- Navigation Bar -->
    <header>
        <h1>DAA-Course Project</h1>
        <nav>
            <ul>
                <li><a href="index.html">Home</a></li>
                <li><a href="Course-Reflections.html">Course Reflections</a></li>
                <li><a href="SDG-mapping.html">SDG Mapping</a></li>
                <li><a href="implementation.html">Implementation</a></li>
            </ul>
        </nav>
    </header>

    <!-- Title -->
    <h1>Course Learning Reflections</h1>

    <!-- Content -->
    <div class="content">
        <h3>1. Iteration, Recursion, and Backtracking</h3>
        <hr>
        <p>
            There are several kinds of phenomena we see in nature that describe or can be solved using DAA techniques like iteration, recursion, and backtracking.
            <ul>
                <li>
                    <strong>Iteration:</strong> The rise and fall of tidal waves is an excellent example of the iteration process where there is a repeated pattern or regularity between each tide.
                </li>
                <li>
                    <strong>Recursion:</strong> The pattern of a cauliflower shows the recursive pattern of the flower from stem to the tips.
                </li>
                <li>
                    <strong>Backtracking:</strong> This is widely applicable in navigating a maze or solving Sudoku. These natural problem-solving techniques can be applied in DAA to solve similar problems in the algorithmic world.
                </li>
            </ul>
        </p>

        <h3>2. Time and Space Efficiency and Orders of Growth</h3>
        <hr>
        <p>
            <ul>
                <li><strong>Time efficiency:</strong> The time taken by an algorithm to execute.</li>
                <li><strong>Space efficiency:</strong> The extra space taken by the algorithm.</li>
                <li>Efficient algorithms are crucial for large datasets as inefficient ones might not run properly or may process slowly.</li>
                <li><strong>Classes of problems:</strong>
                    <ul>
                        <li>O(1) - Constant time</li>
                        <li>O(logn) - Logarithmic time</li>
                        <li>O(n) - Linear time</li>
                        <li>O(nlogn) - Linearithmic time</li>
                        <li>O(n²) - Quadratic time</li>
                        <li>O(n³) - Cubic time</li>
                        <li>O(2ⁿ) - Exponential time</li>
                        <li>O(n!) - Factorial time</li>
                    </ul>
                </li>
            </ul>
        </p>

        <h3>3. Design Principles</h3>
        <hr>
        <p>
            These principles help in problem-solving in data structures by breaking down problems based on available principles. They reduce time and space complexity. For example:
            <ul>
                <li><strong>Partitioning:</strong> Useful for managing large datasets.</li>
                <li>Reliability and accuracy in overcoming challenges are ensured by these principles.</li>
            </ul>
        </p>

        <h3>4. Tree Data Structures</h3>
        <hr>
        <p>
            Tree data structures are hierarchical, based on parent-child relationships, and include:
            <ul>
                <li><strong>BST:</strong> Used for sorted data but can be unbalanced.</li>
                <li><strong>AVL:</strong> A balanced BST with O(logn) efficiency.</li>
                <li><strong>2-3 Tree:</strong> Simpler and dynamic compared to AVL.</li>
                <li><strong>Red-Black Tree:</strong> Suitable for dynamic datasets with fewer rotations.</li>
                <li><strong>Heap:</strong> Used for maximum/minimum problems.</li>
                <li><strong>Trie:</strong> Based on string prefixes, retrieves strings by traversal.</li>
            </ul>
        </p>

        <h3>5. Array Query Algorithm</h3>
        <hr>
        <p>
            Array query algorithms operate on arrays efficiently for tasks like updates or finding maximum/minimum. These techniques:
            <ul>
                <li>Use divide and conquer, lazy propagation, etc.</li>
                <li>Are used in data analysis, dynamic updates, and range queries.</li>
                <li>Applications include Fenwick Tree, Segment Tree, etc.</li>
            </ul>
        </p>

        <h3>6. Difference Between Tree and Graph</h3>
        <hr>
        <p>
            <ul>
                <li><strong>Tree:</strong> Hierarchical, no cycles. Traversal: In-order, Post-order, Pre-order.</li>
                <li><strong>Graph:</strong> Contains cycles, non-hierarchical. Traversal: BFS, DFS.</li>
                <li>Applications: Trees for searching/sorting; Graphs for networking and navigation.</li>
            </ul>
        </p>

        <h3>7. Sorting and Searching</h3>
        <hr>
        <p>
            Sorting organizes data using techniques like:
            <ul>
                <li><strong>Bubble Sort:</strong> Swaps elements in the wrong order.</li>
                <li><strong>Selection Sort:</strong> Places the smallest element in the sorted section.</li>
                <li><strong>Insertion Sort:</strong> Places elements in correct positions in a sorted array.</li>
                <li><strong>Merge Sort:</strong> Divides, sorts, and merges data.</li>
                <li><strong>Quick Sort:</strong> Uses a pivot for partitioning and recursive sorting.</li>
                <li><strong>Heap Sort:</strong> Builds a heap to sort.</li>
            </ul>
            Searching techniques include:
            <ul>
                <li><strong>BFS:</strong> Level-by-level traversal.</li>
                <li><strong>Boyer-Moore:</strong> Uses bad character and good suffix rules.</li>
                <li><strong>KMP:</strong> Uses prefix-suffix table.</li>
                <li><strong>Rabin-Karp:</strong> Uses hashing for pattern matching.</li>
            </ul>
        </p>

       <h3>8. Spanning Tree and Shortest Path</h3>
        <hr>
        <p>
            Spanning trees and shortest path algorithms are fundamental in graph theory:
            <ul>
                <li><strong>Spanning Tree:</strong>
                    <ul>
                        <li>It is a subgraph of a graph that includes all the vertices with the minimum number of edges.</li>
                        <li><strong>Kruskal's Algorithm:</strong> Adds edges in increasing order of weight without forming cycles.</li>
                        <li><strong>Prim's Algorithm:</strong> Grows the tree from an arbitrary starting vertex by adding the smallest edge connecting the tree to a new vertex.</li>
                        <li><strong>Applications:</strong> Network design, such as laying cables or pipelines.</li>
                    </ul>
                </li>
                <li><strong>Shortest Path:</strong>
                    <ul>
                        <li><strong>Dijkstra's Algorithm:</strong> Finds the shortest path from a source to all other vertices in a graph.</li>
                        <li><strong>Bellman-Ford Algorithm:</strong> Handles graphs with negative edge weights and detects negative weight cycles.</li>
                        <li><strong>Floyd-Warshall Algorithm:</strong> Computes shortest paths between all pairs of vertices.</li>
                        <li><strong>Applications:</strong> GPS navigation, routing protocols, and logistics optimization.</li>
                    </ul>
                </li>
            </ul>
        </p>
      
    </div>
</body>
</html>
