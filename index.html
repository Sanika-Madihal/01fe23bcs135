<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chitranagari: Smart City Design</title>
    <link rel="stylesheet" href="style.css">
    <style>
        body {
            background-color: #282a36;
            color: #f8f8f2;
            font-family: 'Roboto', sans-serif;
            line-height: 1.6;
            padding: 20px;
        }

        nav ul {
            list-style: none;
            padding: 0;
        }

        nav ul li {
            display: inline;
            margin-right: 20px;
        }

        nav ul li a {
            color: #f8f8f2;
            text-decoration: none;
            font-size: 18px;
        }

        .section {
            display: none;
        }

        .section.active {
            display: block;
        }

        .highlight {
            font-size: 50px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <header>
        <h1>Chitranagari: Smart City Design</h1>
        <nav>
            <ul>
                <li><a href="#" onclick="showSection('home')">Home</a></li>
                <li><a href="#" onclick="showSection('business-cases')">Business Cases</a></li>
                <li><a href="#" onclick="showSection('course-reflections')">Course Reflections</a></li>
                <li><a href="#" onclick="showSection('sdg-mapping')">SDG Mapping</a></li>
                <li><a href="#" onclick="showSection('implementation')">Implementation</a></li>
                <li><a href="#" onclick="showSection('contact')">Contact</a></li>
            </ul>
        </nav>
    </header>

   <!-- Home Section -->
<div id="home" class="section active">
    <h2>Welcome to the Design and Analysis of Algorithms (DAA) Project</h2>
    <p>This project combines Data Structures and Algorithms (DAA) with real-world challenges, crafting innovative solutions for Chitranagari‚Äôs development. Dive in and see how algorithms drive progress in healthcare, education, and industry.</p>
    
    <!-- Explore Our Journey Section -->
    <div class="header-box">
        <h1>Explore Our Journey</h1>
        <p>Business Cases üåç</p>
        <ul>
            <li><strong>Healthcare Revolution üè•:</strong> Optimize patient-hospital assignment with graph algorithms and prioritize resources with heaps.</li>
            <li><strong>Smart Classrooms üéì:</strong> Simplify scheduling conflicts with Segment and Interval Trees.</li>
            <li><strong>Industrial Growth üè≠:</strong> Boost efficiency in logistics and resource distribution using shortest path and flow algorithms.</li>
        </ul>
    </div>

    <!-- Course Reflections Section -->
    <div class="header-box">
        <h1>Course Reflections üß†</h1>
        <p>From nature-inspired recursion to efficient tree structures, we explored algorithms that optimize speed and memory. Array queries, sorting, and searching sharpened our problem-solving skills, while design principles like Divide and Conquer showed us the beauty of breaking big problems into manageable steps.</p>
    </div>

    <!-- SDG Mapping Section -->
    <div class="header-box">
        <h1>SDG Mapping üå±</h1>
        <p>Our efforts align with SDG 11 (Sustainable Cities and Communities) by:</p>
        <ul>
            <li><strong>Strengthening healthcare systems</strong> with smarter logistics.</li>
            <li><strong>Enhancing educational infrastructure</strong> through resource optimization.</li>
            <li><strong>Boosting industrial efficiency</strong> for sustainable urban growth.</li>
        </ul>
    </div>

    <!-- Implementation Section -->
    <div class="header-box">
        <h1>Implementation üîß</h1>
        <p>Where the magic happens:</p>
        <ul>
            <li><strong>Algorithms in Action:</strong> From Dijkstra‚Äôs and Bellman-Ford to Fenwick Trees and Priority Queues.</li>
            <li><strong>Real-World Problems:</strong> Algorithms meet reality in healthcare, education, and industry.</li>
            <li><strong>Optimization in Every Step:</strong> Achieving efficiency in time and space while solving complex challenges.</li>
        </ul>
    </div>
</div>

<!-- Business Cases Section -->
<div id="business-cases" class="section">
    <h2>Business Cases Identified by Sanika M Madihal (01FE23BCS135)</h2>

    <h3>1. Waste Management for Industries</h3>
    <p>Chitranagari is a city located in Rajasthan which is facing problems in managing the industrial waste caused by its handicrafts and textile industries and also since it is located near the fields the disposal might be hazardous for crops. The improper disposal of waste might rise issues like polltuion of water bodies and loss of yield in the fields. This needs a sustainable sensitive waste management system that helps in maintaining and preserving the clean environment for future generations.</p>

    <h3>2. Import and Export of Goods</h3>
    <p>Since the city Chitranagari is known for its cultural heritage and handicrafts, most of the people's livelyhood depends on the import of raw materials and export of the goods. The main challenges are faced due to lack of networking and limited acces to market data. We need a modern technology import-export system which has the capacity to support Chitranagari's people and make sure that they reach the global markets.</p>

    <h3>3. Improving Living Standards for Farmers</h3>
    <p>The farmers of Chitranagari face significant challenges like both in livelihood and living conditions. Along with irregular rainfall and limited market access, many farmers live in inadequate housing with poor access to basic needs like clean water, electricity, etc. A complete solution is needed to improve both the living conditionds and latest farming techniques, ensuring better livelihoods while preserving the economic sustainability.</p>
</div>


   <!-- Course Reflections Section -->
<div id="course-reflections" class="section">
    <h2>Course Learning Outcomes</h2>

    <h3>1. Iteration, Recursion and Bactracking</h3>
    <p>There are several kind of phenomena we see in the nature which describes or can be solved using the daa techniques like iteration, recursion and backtracking. For instance when it comes to iteration the rise and fall of the tidal waves is one of the best example to explain the iteration process where there is repeated pattern or regularity between each tide. Recursion is best described by the pattern of the cauliflower which shows the recursive pattern of the flower from stem to the tips. Whereas, backtracking is widely applicable in navigating the maze OR sudoku. We can use these natural problem solving techniques in daa to solve similar kind of problems in algorithmic world</p>
 
    <h3>2. Time and Space efficiency and orders of growth</h3>
    <p>Time efficiency is defined as the time taken by algorithm to execute or how long an algorithm takes to execute.</p>
    <p>Space efficiency is defined as the extra space taken by the algorithm.</p>
    <p>Importance of time and space efficiency is that when there is a large set of data and if the algorithm is inefficient it might not run properly or it may not give instant outputs(slow processing). The different class of problems are:
</p>
    <ul>
        <li><strong>Constant time :</strong> The runtime remains the same regardless of the input size.Represented as O(1).</li>
        <li><strong>Logarithmic time :</strong> The runtime grows slowly, increasing logarithmically as the input size grows. Represented as O(logn).</li>
        <li><strong>Linear time :</strong> The runtime increases proportionally to the input size. Represented as O(n).</li>
        <li><strong>Linearithmic time :</strong> The runtime grows faster than linear but slower than quadratic. Represented as O(nlogn).</li>
        <li><strong>Quadratic time :</strong> The runtime grows quadratically. Represented as O(n^2)</li>
        <li><strong>Cubic time :</strong> The runtime increases even more steeply that quadratic. Represented as O(n^3).</li>
        <li><strong>Exponential time :</strong> The runtime grows exponentially, with each additional input. Represented as O(2^n).</li>
        <li><strong>Factorial time :</strong> The runtime grows extremely fast.Represented as O(n!).</li>
    </ul>

    <h3>3. Design Principles</h3>
    <p>These principles helps us in problem solving in data structures by relating and breaking down the problem according to the available principles. Also these provides the best efficiency by reduicing space and time complexity. Some principles like partioning allows us to manange different types of large data sets. These principles are reliable and accurate for overcoming the challenges.</p>

    <h3>4. Tree Data Structures</h3>
    <p>The hierarchical data structures like tree are based on parent-child relationship and these are:</p>
    <ul>
        <li><strong>BST:</strong> This helps in searching, insertion and deletion of sorted data but sometimes it can be unbalanced affecting the efficiency.</li>
        <li><strong>AVL:</strong> This is balanced BST and has an efficiency of O(log n).</li>
        <li><strong>2-3 tree:</strong> This is used for dynamic set of data. It is simple compared to AVL./li>
        <li><strong>Red-Black tree:</strong> Even this is used in case of dynamic dataset with less number of rotations.</li>
        <li><strong>Heap:</strong> This is used in case of problems like maximum/minimum.</li>
        <li><strong>Trie:</strong>  This is based on the prefix of the string. Here string is retrieved by traversing.</li>
    </ul>

    <h3>5.Array Query Algorithm</h3>
    <p>Array query algorithms is a technique used to operate arrays efficiently with respect to particular query like update, maximum or minimum. These are used to obatin the most efficient algorithm by reducing the complexities and to handle large datasets. Different types of principles used are divide and conquer, lazy propagation, etc. to operate efficiently. Coming to applications we can use fenwick tree, segment tree and many moe for data analysis and dynamic updtaes and also for range queries.</p>

    <h3>6. Difference between Tree and Graph</h3>
    <p>A tree doesnt have cycles in it and it follows hierarchy. Traversal follows in-order, post-order and pre-order. A graph consists of cycles and it doesnt follow hierarchy. Traversal is done thriugh BFS and DFS. Application of tree include in searching and sorting of large datasets and also priority queues. Graphs are mainly used in networking and navigation like roadlines airlines, etc.</p>

    <h3>7. Sorting and Searching</h3>
    <p>Sorting organizes data in a specific order using techniques like bubble, quick, etc.</p>
    <ul>
        <li><strong>Bubble sort:</strong> It repeatedly swaps the elements which are in wrong order. basic algorithm required to understand sorting</li>
        <li><strong>Selection sort:</strong> The smallest element from the inoput is selected and placed in sorted section. It can be used to choose the smallest item from the list</li>
        <li><strong>Insertion sort:</strong> Sorted array is obtained by inserting elemnts in the correct position. Sorting of numbered cards.</li>
        <li><strong>Merge sort:</strong> Firstly divides the array into half, sorts and then merges them. Used to sort large files or datasets.</li>
        <li><strong>Qucik sort:</strong> Uses pivot to partition the data and then sorts recursively.</li>
        <li><strong>Heap sort:</strong> Builds a max or min heap and extracts the root to obtain sorted array.</li>
    </ul>
    <p>Searching refers to finding an element within a data.</p>
    <ul> 
        <li><strong>BFSS:</strong>strong> It uses queue to manage nodes and goes level by level in a graph. Used to find paths in map.</li>
        <li><strong>Boyer-Moore:</strong> This uses bad character and good suffix to skip some comparisions and searches for pattern by comparing from right to left. Searching words in a document</li>
        <li><strong>Knuth-Morris-Pratt:</strong> Uses prefix and suffix table to skip comparision.</li>
        <li><strong>Rabin-Karp:</strong> Uses hashing to find a pattern in given text.</li>
    </ul>

     <h3>8. Spanning Tree and Shortest Path</h3>
    <p>These graph algorithms are widely applicable in real life applications like finding the shortest path or in networking world.</p>
    <ul>
        <li><strong>Spanning Tree:</strong> In this all the vertices are connected with no cycles. -Kruskal's algorithm first sorts and keep adding the edges until it forms spanning tree n it doesnt form cycle. -Dijkstra's doesnt visit every node but it can find the shortest path While other algorithms are used to fins whether there exists a path or shortest path or no like in Floyd's, etc.</li>
        <li><strong>Shortest Path:</strong> This algorithm is used to find the shortest path between two vertices. For example kruskal's and dijkstra's are used to find the shortest path.</li>
    </ul>
</div>

    <!-- SDG Mapping Section -->
<div id="sdg-mapping" class="section">
    <h2>SDG Mapping</h2>

  <h3>1. Waste Management for Industries ‚ôªÔ∏è</h3>
<p>To establish Chitranagari as a prime hub for industrial development while ensuring sustainable growth by creating dedicated industrial zones for small, medium, and large-scale industries.</p>

<h4>SDG 11 Target 11.6: Reduce environmental impact of cities.</h4>
<p>Chitranagari's goal is to recycle 80% of industrial waste by establishing a centralized waste treatment plant. The city will also introduce waste segregation units and incentivize industries to adopt eco-friendly practices, ensuring a cleaner, greener environment.</p>

<h4>SDG 11 Target 11.2 (Indirect): Provide access to sustainable transport systems.</h4>
<p>Industrial waste is currently transported in unregulated vehicles, causing environmental harm. Chitranagari plans to deploy 20 specialized waste transport vehicles equipped with sealed containers to ensure safe and efficient transit of waste to recycling or disposal sites.</p>

<h4>SDG 11 Target 11.4: Protect and safeguard cultural and natural heritage.</h4>
<p>The handicrafts sector, employing 10,000 artisans, faces challenges due to unsustainable waste disposal. To preserve the city's cultural heritage while promoting sustainability, the "Eco-Crafts Initiative" will integrate sustainable materials and waste reuse in production processes.</p>
<h3>
    
  <h3>2. Import and Export of Goods üåê</h3>
<p>To establish a modern import-export system that supports Chitranagari‚Äôs handicraft industry, ensures access to global markets, and facilitates sustainable urban development.</p>

<h4>SDG 11 Target 11.3: Enhance inclusive and sustainable urbanization.</h4>
<p>To foster inclusive growth, Chitranagari will implement a digital platform that provides access to market data, connecting local artisans to global buyers. This initiative enhances urban infrastructure for trade, boosts market access for small-scale industries, creates job opportunities, and ensures sustainable urban development.</p>

<h4>SDG 11 Target 11.6: Reduce environmental impact of cities.</h4>
<p>The city will integrate green logistics into its import-export system, optimizing transportation routes and using energy-efficient modes of transport for raw material imports and finished goods exports. These measures reduce the carbon footprint of trade operations and promote environmentally responsible business practices, reinforcing Chitranagari's commitment to sustainability.</p>
<h3>
    
   <h3>3. Improving Living Standards for Farmers üåæ</h3>
<p>To enhance farmers‚Äô living standards by improving housing, access to basic utilities, and modernizing agricultural practices, ensuring sustainable livelihoods and economic resilience.</p>

<h4>SDG 11 Target 11.1: Ensure access for all to adequate, safe, and affordable housing and basic services.</h4>
<p>Affordable housing schemes will be developed for farmers, featuring access to clean water, sanitation, and electricity. Solar energy systems will be introduced to provide a consistent power supply. These efforts will improve living standards, ensure safe housing, and meet the basic needs of Chitranagari‚Äôs farming community.</p>

<h4>SDG 11 Target 11.3: Enhance inclusive and sustainable urbanization.</h4>
<p>Training programs will be provided to farmers to adopt modern agricultural techniques and practices. This initiative will enhance productivity while ensuring environmental sustainability, promoting sustainable rural development, and connecting farmers to urban markets to foster inclusive economic growth.</p>

   </div>


    <!-- Implementation Section -->
<div id="implementation" class="section">
    <h2>Implementation Section</h2>

   <h1>Waste management for Industries</h1>
<hr>
<h2>1. Waste Segregation using Trie and Hashing</h2>
<p><strong>Idea:</strong> Categorize industrial waste efficiently using Trie structures and hashing for accurate segregation and treatment.</p>
<p><strong>Description:</strong></p>
<ul>
    <li><strong>Trie Structure:</strong> 
        <ul>
            <li>Root node represents "Industrial Waste."</li>
            <li>Child nodes represent specific industries (e.g., Handicrafts, Textiles).</li>
            <li>Further levels classify waste types (e.g., Chemical -> Dyes, Solid -> Fabric).</li>
        </ul>
    </li>
    <li><strong>Hashing:</strong>
        <ul>
            <li>Use a hash table where keys are waste types (e.g., "Dye Waste") and values are corresponding disposal or treatment methods.</li>
            <li>Enables quick lookup for waste management strategies.</li>
        </ul>
    </li>
    <li><strong>Implementation Benefits:</strong>
        <ul>
            <li>Efficient categorization for waste treatment and disposal.</li>
            <li>Scalability for managing diverse waste types from multiple industries.</li>
            <li>Streamlined integration into waste management systems.</li>
        </ul>
    </li>
</ul>

   <h2>2. Optimal Waste Collection using Greedy Technique and Dijkstra‚Äôs Algorithm</h2>
<p><strong>Idea:</strong> Optimize waste collection routes and priorities to minimize environmental impact and ensure the timely disposal of hazardous waste using graph-based techniques.</p>
<p><strong>Description:</strong></p>
<ul>
    <li><strong>Graph Construction:</strong>
        <ul>
            <li><strong>Nodes:</strong> Represent industrial waste generation points (e.g., factories).</li>
            <li><strong>Edges:</strong> Represent transportation routes weighted by distance, cost, and environmental impact.</li>
            <li><strong>Complexity:</strong> Graph construction has a time complexity of <code>O(V + E)</code>.</li>
        </ul>
    </li>
    <li><strong>Dijkstra's Algorithm:</strong>
        <ul>
            <li>Calculates the shortest path for waste collection vehicles to reduce fuel consumption.</li>
            <li><strong>Implementation:</strong> Uses a priority queue (e.g., min-heap) for efficiency.</li>
            <li><strong>Time Complexity:</strong> <code>O((V + E) ‚ãÖ log V)</code>.</li>
            <li><strong>Space Complexity:</strong> <code>O(V + E)</code>.</li>
            <li><strong>Example:</strong> Start at a waste collection depot and visit factories based on proximity and waste priority.</li>
        </ul>
    </li>
    <li><strong>Greedy Technique:</strong>
        <ul>
            <li>Prioritize the collection of hazardous waste (e.g., chemical dyes) first to prevent environmental risks.</li>
            <li><strong>Implementation:</strong> Sort factories by waste priority (e.g., hazardous waste) before collection.</li>
            <li><strong>Time Complexity:</strong> Sorting factories involves <code>O(V log V)</code>.</li>
        </ul>
    </li>
    <li><strong>Implementation Benefits:</strong>
        <ul>
            <li>Reduces transportation costs and environmental impact.</li>
            <li>Ensures safe and timely disposal of hazardous materials.</li>
            <li>Streamlines waste collection for better resource utilization.</li>
        </ul>
    </li>
</ul>
    
    <h2>3. Sustainable Treatment using Dynamic Programming (DP)</h2>
<p><strong>Idea:</strong> Optimize treatment costs for small-scale industries while maximizing recycling using dynamic programming.</p>
<p><strong>Description:</strong></p>
<ul>
    <li><strong>Implementation:</strong>
        <ul>
            <li>Based on the amount and type of waste (e.g., X kg of dye waste), determine treatment options (e.g., neutralization, incineration).</li>
        </ul>
    </li>
    <li><strong>DP Objective:</strong>
        <ul>
            <li>Minimize treatment cost and environmental impact (E) while maximizing resource recovery (R).</li>
        </ul>
    </li>
</ul>

   <h2>4. Sustainable Disposal using Backtracking</h2>
<p><strong>Idea:</strong> Ensure waste disposal methods align with SDG goals and prevent harm to agricultural fields using backtracking.</p>
<p><strong>Description:</strong></p>
<ul>
    <li><strong>Implementation:</strong>
        <ul>
            <li>Backtracking explores all disposal options for a given waste type (e.g., recycling, composting, landfill).</li>
            <li>Backtrack and prune paths that lead to non-compliant solutions.</li>
        </ul>
    </li>
</ul>

 <h2>5. Pollution Control using Lazy Propagation and Fenwick Tree</h2>
<p><strong>Idea:</strong> Monitor pollution levels near industries, water bodies, and fields in real-time using efficient data structures.</p>
<p><strong>Description:</strong></p>
<ul>
    <li><strong>Implementation:</strong>
        <ul>
            <li><strong>Lazy Propagation:</strong> Update pollution metrics (e.g., air and water quality indices) only when a significant change is detected.</li>
            <li><strong>Fenwick Tree:</strong> Maintain cumulative pollution data for quick identification of hotspots.</li>
        </ul>
    </li>
    <li><strong>Complexities:</strong>
        <ul>
            <li>Updating pollution data for a specific zone (e.g., adding pollution due to a new discharge) takes <code>O(log N)</code>.</li>
            <li>The Fenwick Tree requires <code>O(N)</code> space, where <code>N</code> is the number of zones.</li>
        </ul>
    </li>
</ul>
    
     <h1>Import and Export of Goods</h1>
<hr>
<h2>1. Building a Trade Network (Kruskal‚Äôs Algorithm)</h2>
<p><strong>Idea:</strong> Optimize the trade network in Chitranagari by connecting trade hubs efficiently to minimize transportation costs and improve accessibility.</p>
<p><strong>Description:</strong></p>
<ul>
    <li><strong>Implementation:</strong>
        <ul>
            <li>Represent trade hubs as nodes and transportation routes as edges, weighted by costs.</li>
            <li>Sort all edges (routes) by weight (cost).</li>
            <li>Add edges to the Minimum Spanning Tree (MST) one by one, ensuring no cycles are formed, until all nodes are connected.</li>
        </ul>
    </li>
    <li><strong>Complexities:</strong>
        <ul>
            <li><strong>Graph Representation:</strong> Requires <code>O(E)</code> time and <code>O(V + E)</code> space.</li>
            <li><strong>Sorting Edges:</strong> Takes <code>O(E log E)</code> time and <code>O(E)</code> space.</li>
            <li><strong>Union-Find Operations:</strong> Used for cycle detection with a time complexity of <code>O(E ‚ãÖ Œ±(V))</code>, where <code>Œ±(V)</code> is the inverse Ackermann function, and a space complexity of <code>O(V)</code>.</li>
            <li><strong>Total Time Complexity:</strong> <code>O(E log E)</code>.</li>
            <li><strong>Total Space Complexity:</strong> <code>O(V + E)</code>.</li>
        </ul>
    </li>
</ul>

<h2>2. Cost-Effective Route Selection (Heap)</h2>
<p><strong>Idea:</strong> Optimize operational logistics by selecting daily transport routes or scheduling shipments in a cost-effective manner using a Min-Heap.</p>
<p><strong>Description:</strong></p>
<ul>
    <li><strong>Implementation:</strong>
        <ul>
            <li>Use a Min-Heap to store all transport routes, where the smallest cost route is always at the root.</li>
            <li>Continuously extract and prioritize the cheaper routes, reducing overall transportation expenses.</li>
        </ul>
    </li>
</ul>

<h2>3. Load Balancing Across Markets (Partitioning)</h2>
<p><strong>Idea:</strong> Address unequal demand for textiles and handicrafts in different regions by partitioning markets to ensure equitable distribution of resources and smooth operations.</p>
<p><strong>Description:</strong></p>
<ul>
    <li><strong>Implementation:</strong>
        <ul>
            <li>Divide markets into high-demand and low-demand groups based on historical data.</li>
            <li>Assign more vehicles, workforce, and inventory to high-demand hubs.</li>
            <li>Gradually shift resources from low-demand hubs as needed.</li>
        </ul>
    </li>
</ul>

 <h1> Improving Living Standards for Farmers</h1>
<hr>
<h2>1. Smart Education System (Graph & Shortest Path Algorithms)</h2>
<p><strong>Idea:</strong> Model the education network (schools, colleges, research institutions) as a graph to optimize communication and resource allocation.</p>
<p><strong>Description:</strong></p>
<ul>
    <li><strong>Graph Representation:</strong> Nodes represent educational institutions; edges represent pathways or communication networks.</li>
    <li><strong>Design Techniques:</strong>
        <ul>
            <li>Dijkstra‚Äôs Algorithm or A* Search for optimizing travel paths between institutions.</li>
            <li>Time Efficiency: Dijkstra‚Äôs algorithm runs in O(E log V).</li>
            <li>Space Efficiency: Space complexity is O(V + E).</li>
        </ul>
    </li>
</ul>

<h2>2. E-learning Platforms and Resource Allocation (Hashing, Lookup Tables, Binary Search Tree)</h2>
<p><strong>Idea:</strong> Efficiently manage e-learning resources and platform data such as course catalogs, student data, and faculty information.</p>
<p><strong>Description:</strong></p>
<ul>
    <li><strong>Hashing:</strong> Use hash tables for fast access to student records, course data, and faculty information.</li>
    <li><strong>Lookup Tables:</strong> Store fixed data such as course prerequisites, student enrollment status, or faculty availability.</li>
    <li><strong>Binary Search Tree (BST):</strong> Maintain an ordered list of students, courses, or faculty members.</li>
    <li><strong>Design Techniques:</strong>
        <ul>
            <li>AVL Tree or Red-Black Tree for maintaining sorted data for efficient searching.</li>
            <li>Time Efficiency: Hashing offers O(1) lookup, while BST operations take O(log n).</li>
            <li>Space Efficiency: Hash tables use O(n), while BSTs use O(n).</li>
        </ul>
    </li>
</ul>

<h2>3. Enrollment System (Priority Queue/Heap)</h2>
<p><strong>Idea:</strong> Prioritize student enrollments based on available seats, course preferences, or admission scores.</p>
<p><strong>Description:</strong></p>
<ul>
    <li><strong>Min-Heap or Max-Heap:</strong> Prioritize students for course enrollment based on score, preference, or availability.</li>
    <li><strong>Design Techniques:</strong>
        <ul>
            <li>Greedy Technique: Always enroll the highest-priority student available.</li>
            <li>Time Efficiency: Heap operations run in O(log n).</li>
            <li>Space Efficiency: The space complexity is O(n).</li>
        </ul>
    </li>
</ul>

<h2>4. Classroom Scheduling (Interval Tree, Segment Tree)</h2>
<p><strong>Idea:</strong> Optimize classroom scheduling and resource allocation across different institutions.</p>
<p><strong>Description:</strong></p>
<ul>
    <li><strong>Segment Tree:</strong> Use for managing time slots and available classrooms across multiple institutions.</li>
    <li><strong>Interval Tree:</strong> Efficiently manage classroom availability and prevent conflicts during scheduling.</li>
    <li><strong>Design Techniques:</strong>
        <ul>
            <li>Segment Tree allows for efficient querying of available time slots.</li>
            <li>Interval Tree handles overlapping class schedules.</li>
            <li>Time Efficiency: Both trees provide O(log n) query and update time.</li>
            <li>Space Efficiency: Space complexity for both trees is O(n).</li>
        </ul>
    </li>
</ul>

<h2>5. Student and Faculty Management (Linked List, Binary Search Tree)</h2>
<p><strong>Idea:</strong> Manage dynamic data about students, faculty, and staff, including shifts, roles, and activities.</p>
<p><strong>Description:</strong></p>
<ul>
    <li><strong>Linked List:</strong> Use for dynamically managing student or faculty details, where data might change frequently (e.g., grades, shifts).</li>
    <li><strong>Binary Search Tree (BST):</strong> Organize students or faculty members based on specific attributes like GPA or department.</li>
    <li><strong>Design Techniques:</strong>
        <ul>
            <li>Lazy Propagation: Update records only when necessary, especially in large institutions.</li>
            <li>Time Efficiency: Linked list operations are O(1) for insertion and deletion, and BST operations take O(log n).</li>
            <li>Space Efficiency: Linked lists and BSTs both require O(n) space.</li>
        </ul>
    </li>
</ul>

<h2>6. Online Examination System (Queue/Deque)</h2>
<p><strong>Idea:</strong> Manage the flow of students during online examinations, ensuring efficient exam scheduling and result processing.</p>
<p><strong>Description:</strong></p>
<ul>
    <li><strong>Queue:</strong> Manage students waiting for exam entry, ensuring fair processing in a First-In-First-Out (FIFO) manner.</li>
    <li><strong>Deque:</strong> A double-ended queue can manage students entering or leaving the exam in different phases.</li>
    <li><strong>Design Techniques:</strong>
        <ul>
            <li>Lazy Propagation: Only update records when a student enters or exits the exam.</li>
            <li>Time Efficiency: Queue and deque operations are O(1).</li>
            <li>Space Efficiency: The space complexity is O(n).</li>
        </ul>
    </li>
</ul>

<h2>7. Performance Analytics (Fenwick Tree, Sparse Table)</h2>
<p><strong>Idea:</strong> Track and analyze performance data such as exam scores, attendance, and project submissions.</p>
<p><strong>Description:</strong></p>
<ul>
    <li><strong>Fenwick Tree:</strong> Track cumulative performance metrics such as total grades or attendance.</li>
    <li><strong>Sparse Table:</strong> Efficiently query performance data across large datasets for static queries like overall exam performance.</li>
    <li><strong>Design Techniques:</strong>
        <ul>
            <li>Fenwick Tree helps with cumulative performance tracking.</li>
            <li>Sparse Table is ideal for static range queries.</li>
            <li>Time Efficiency: Fenwick Tree operations take O(log n), and Sparse Table queries are O(1).</li>
            <li>Space Efficiency: Both structures use O(n) space.</li>
        </ul>
    </li>
</ul>

<h2>8. Scholarship Management (Priority Queue/Heap)</h2>
<p><strong>Idea:</strong> Manage scholarships by prioritizing students based on merit, need, and other factors.</p>
<p><strong>Description:</strong></p>
<ul>
    <li><strong>Min-Heap or Max-Heap:</strong> Use a heap to prioritize students for scholarships based on their scores or financial need.</li>
    <li><strong>Design Techniques:</strong>
        <ul>
            <li>Greedy Technique: Allocate scholarships to the most eligible students based on priority.</li>
            <li>Time Efficiency: Heap operations are O(log n).</li>
            <li>Space Efficiency: The space complexity is O(n).</li>
        </ul>
    </li>
</ul>

<h2>9. Course Recommendation System (Graph, Dynamic Programming)</h2>
<p><strong>Idea:</strong> Recommend courses to students based on their past choices, interests, and academic performance.</p>
<p><strong>Description:</strong></p>
<ul>
    <li><strong>Graph:</strong> Represent course prerequisites and student interests as a graph to recommend the next best course.</li>
    <li><strong>Dynamic Programming:</strong> Use dynamic programming to find the optimal course selection based on prior selections and student preferences.</li>
    <li><strong>Design Techniques:</strong>
        <ul>
            <li>Dynamic Programming can optimize the recommendation process.</li>
            <li>Time Efficiency: The time complexity for dynamic programming is typically O(n¬≤) or O(n log n) based on the problem size.</li>
            <li>Space Efficiency: Space complexity is O(n) for storing previous results.</li>
        </ul>
    </li>
</ul>

<h2>10. Virtual Labs and Simulations (Queue/Deque, Graph)</h2>
<p><strong>Idea:</strong> Manage virtual labs and simulations where students can conduct experiments in an online environment.</p>
<p><strong>Description:</strong></p>
<ul>
    <li><strong>Queue/Deque:</strong> Manage the queue of students awaiting access to virtual labs or simulations.</li>
    <li><strong>Graph:</strong> Model the experiments as a graph to track various steps in a virtual experiment.</li>
    <li><strong>Design Techniques:</strong>
        <ul>
            <li>Lazy Propagation: Only update when the student enters or finishes an experiment.</li>
            <li>Time Efficiency: Queue and deque operations are O(1).</li>
            <li>Space Efficiency: The space complexity is O(n).</li>
        </ul>
    </li>
</ul>


    <!-- Contact Section -->
    <div id="contact" class="section">
        <h2>Contact</h2>
        <p>Email: contact@chitranagari.com</p>
        <p>Phone: +91 12345 67890</p>
    </div>

    <script>
        function showSection(sectionId) {
            // Hide all sections
            const sections = document.querySelectorAll('.section');
            sections.forEach(section => section.classList.remove('active'));

            // Show the selected section
            const selectedSection = document.getElementById(sectionId);
            selectedSection.classList.add('active');
        }
    </script>
</body>
</html>
