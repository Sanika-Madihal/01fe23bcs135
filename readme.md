## *SMART CITY DESIGN*

Handled by SANIKA MADIHAL : 01FE23BCS135

## *Business case identified*
1. Waste management for industries
2. Import and export of goods
3. Improving living standards for farmers

## *COURSE LEARNING REFLECTIONS*
1. There are several kind of phenomena we see in the nature which describes or can be solved using the daa techniques like iteration, recursion and backtracking. For instance when it comes to iteration the rise and fall of the tidal waves is one of the best example to explain the iteration process where there is repeated pattern or regularity between each tide.Recursion is best described by the pattern of the cauliflower which shows the recursive pattern of the flower from stem to the tips.Whereas, backtracking is widely applicable in navigating the maze. We can use these natural problem solving techniques in daa to solve similar kind of problems in algorithmic world
2. Time efficiency is defined as the time taken by algorithm to execute or how long an algorithm takes to execute. Space efficiency is defined as the extra space taken by the algorithm. Importance of time and space efficiency is that when there is a large set of data and if the algorithm is inefficient it might not run properly or it may not give instant outputs(slow processing). The different class of problems are:
   1.Constant time : The runtime remains the same regardless of the input size.Represented as O(1).
   2.Logarithmic time : The runtime grows slowly, increasing logarithmically as the input size grows. Represented as O(logn).
   3.Linear time : The runtime increases proportionally to the input size. Represented as O(n).
   4.Linearithmic time : The runtime grows faster than linear but slower than quadratic. Represented as O(nlogn).
   5.Quadratic time : The runtime grows quadratically. Represented as O(n^2)
   6.Cubic time : The runtime increases even more steeply that quadratic. Represented as O(n^3).
   7.Exponential time : The runtime grows exponentially, with each additional input. Represented as O(2^n).
   8.Factorial time : The runtime grows extremely fast.Represented as O(n!).
3. These principles helps us in problem solving in data structures by relating and breaking down the problem according to the available principles. Also these provides the best efficiency by reduicing space and time complexity. Some principles like partioning allows us to manange different types of large data sets. These principles are reliable and accurate for overcoming the challenges.
4. The hierarchical data structures like tree are based on parent-child relationship and these are:
   1. BST: This helps in searching, insertion and deletion of sorted data but sometimes it can be unbalanced affecting the efficiency.
   2. AVL: This is balanced BST and has an efficiency of O(log n).
   3. 2-3 tree: This is used for dynamic set of data. It is simple compared to AVL.
   4. Red-Black tree: Even this is used in case of dynamic dataset with less number of rotations.
   5. Heap: This is used in case of problems like maximum/minimum.
   6. Trie: This is based on the prefix of the string. Here string is retrieved by traversing.
5. Array query algorithms efficiently handle operations like range queries and updates on large datasets with frequent queries. Structures like Segment Trees and Fenwick Trees enable quick range sums and updates in applications such as databases and game score tracking, while Sparse Tables optimize static range queries. By dividing arrays into segments or using pre-computation, these algorithms ensure fast and efficient processing.
6. Array query algorithms efficiently handle range queries and updates on large datasets using structures like Segment Trees and Fenwick Trees for dynamic queries and Sparse Tables for static queries, optimizing time and space through segmentation or pre-computation. Trees are hierarchical, acyclic structures used in file systems and binary searches, while graphs are general structures with nodes and edges, used in social networks and pathfinding. Trees focus on hierarchy, while graphs handle interconnected relationships.
7. Sorting organizes data in a specific order using techniques like Quick Sort and Merge Sort or Counting and Radix Sort. Applications include databases, product ranking, and scheduling. Searching locates items in datasets using Linear Search or Binary Search. Itâ€™s crucial for tasks like search engines and inventory lookups. Together, sorting and searching optimize decision-making systems and data usability in real-world applications.
